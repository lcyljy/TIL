- . : 모든 문자 일치
- | : OR 왼쪽 문자(혹은 패턴) 혹은 오른쪽 문자(혹은 패턴)과 일치
- [] : 문자 집합 구성원 중 하나와 일치
  - ex) [abc] : a 혹은 b 혹은 c
- [^] : 문자 집합 구성원을 제외하고 일치, [^abc] : a, b, c 제외한 모든 문자
- - : 범위 정의 ([A-Z]와 같은 형태로 대문자 A에서 Z사이의 문자를 의미)
- \ : 다음에 오는 문자를 이스케이프
- - : 앞의 문자나 부분식이 0개 이상 탐욕적으로 찾기
- *? : 탐욕적 수량자 *를 게으른(lazy) 수량자로 바꿔 찾기
- - : 앞의 문자나 부분식을 하나 이상 탐욕적으로 찾기
- +? : 탐욕적 수량자 +를 제으른(lazy) 수량자로 바꿔 찾기
- ? : 앞의 문자나 부분식을 0개나 1개 찾기
- {n} : 앞의 문자나 부분식이 정확히 n번 일치하는 경우 찾기
- m,n} : 앞의 문자나 부분식이 m번에서 n번 일치하는 경우 찾기
- n,} : 앞의 문자나 부분식이 n번 이상인 경우를 탐욕적으로 찾기
- n,}? : 탐욕적 수량자 {n,}를 게으른(lazy) 수량자로 바꿔 찾기
- ^ : 입력 문자열의 시작에서 그 다음 나오는 문자나 부분식과 일치하는지 검사
- \A : 어떤 정규식에서는 ^의 역할을 함
- $ : 문자열의 끝과 일치
- \Z : 어떤 정규식에서는 $의 역할을 함
- \b : 단어 경계(단어와 공백 사이의 위치)와 일치
  - 예) 'st\b'는 "test"의 st는 찾지만, "tester"의 st는 찾지 않음
  - - test test에서 test 사이의 빈공간인 space와는 다른 의미
- \B : \b와 반대(비단어 경계)로 일치. 즉 "\b"의 예제의 반대 결과가 나옴
- [\b] : 역스페이스
- \cx : 로 표시된 제어문자 찾기. x는 [A-Za-z] 이어야 함. 아니면 c는 리터럴 'c'로 간주
  - 예) \cM = Contorl-M 이나 캐리지 리턴 문자
- \d : 모든 숫자와 일치. [0-9]와 동일
- \D : \d와 반대. [^0-9]와 동일
- \f : 용지 공급 문자 찾기. 페이지 넘기기(formfeed) = \x0a, \cL
- \n : 줄 바꿈 문자 찾기. \x0a, \cJ
- \r : 캐리지 리턴. \x0d, \cM
- \s : 공백, 택, 용지 공급 등과 같은 문자 찾기. [\f\n\r\t\v]
- \S : \s와 반대로 일치. [^\f\n\r\t\v]
- \t : 탭 문자 찾기. \x09, \cI
- \v : 세로 탭 문자 찾기. \x0b, \cK
- \w : 영숫자 문자나 밑줄과 일치. [a-zA-Z0-9]
- \W : \w와 반대로 일치. [^a-za-z0-9]
- \xn : n으로 표시된 16진수 이스케이프 값과 일치. 16진수는 정확히 2자리여야 함
- \0n : n으로 표시된 8진수 숫자와 일치. 가급적 사용하지 않는 것이 좋음
- (pattern) : 하위 표현식 정의. 패턴을 찾아 일치하는 항목을 캡처하는 부분식. 가로 자체 '('나')'를 찾고 싶으면 ''를 붙여 이스케이프하면 된다. '(', ')'
- \1 : 첫 번째 일치한 하위 표현식, 두 번째 일치한 하위 표현식은 \2로 표기
- (?=pattern) : 전방탐색
- (?!pattern) : 부정형 전방탐색
- BR)true : 조건 지정
- (BR)true|false : else 표현식 조건 지정
- \E : \L 혹은 \U 변환을 끝냄
- \I : 다음에 오는 글자를 소문자로 변환
- \L : \E를 만날 때까지 모든 문자를 소문자로 변환
- \u : 다음에 오는 글자를 대문자로 변환
- \U : \E를 만날 때까지 모든 문자를 대문자로 변환
- i : ignore case, 대소문자를 무시하여 찾음. 굳이 [a-zA-Z]라고 할 필요가 없음
- g : global, 찾는 패턴을 하나만 찾지 말고 계속 해서 찾음. 탐욕적 수량자처럼 일치하는 구간을 늘리는 것이 아니라 일치하는 패턴의 개수가 늘어남
- m : multiline, 다중행 모드라고도 하며 라인 별로 처리하는 것이 아니라 입력 문자열에 줄바꿈이 있어도 이를 특수문자로 변환하여 하나로 봄. 가장 큰 차이를 경험할 수 있는 기능은 ^와 $임.

### 우선순위

\ : 이스케이프

(), (?:), (?=), [] : 괄호와 대괄호

, +, ?, {n}, {n,}, {n,m} : 수량자

^, $, \anymetacharacter : 앵커와 시퀀스

| : 교체

### 기본적인 정규식

- abc : abc 가 있는 것
- ^abc : abc 로 시작하는 것
- abc$ : abc 로 끝나는 것
- ^abc$ : ^abc$ abc 로 시작하고 끝나는 것
- [abc] : a,b,c 전부 중 하나를 포함한 경우
- [a-z] : a 에서 z 중 하나를 포함한 경우
- ^[0-9] : 숫자 0~9 중 하나로 시작하는 패턴을 찾는 것
- [^0-9] : 숫자가 들어있지 않는 패턴을 찾는 것
- ^[^0-9] : 숫자가 들어있지 않은 문자로 시작하는 패턴을 찾는 것
- a{3} : a 의 3번 반복인 aaa 인 것
- a{3,} : a 가 3번이상 반복인 것
- [0-9]{2 : 두 자리 숫자
- abc[7-9]{2} : abc 를 포함하고 7~9까지 숫자 중 2자리가 포함하는 것

### 대표적으로 많이 사용하는 정규식

- 이메일 : /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,4}$/
- 집전화번호 : "/^(070|02|031|032|033|041|042|043|051|052|053|054|055|061|062|
  063|064)-\d{3,4}-\d{4}$/u"
- 휴대폰번호 : /^(010|011|016|017|018|019)-\d{3,4}-\d{4}$/u
- 우편번호 : /^\d{3}-?\d{3}$/u
- 아이디 : /^[a-zA-Z]\w{2,7}$/u
- 주민등록번호 : /^\d{2}[0-1]\d[0-3]\d-?[1-6]\d{6}$/u

### 태그 제거(HTML)

- iframe 제거 : $STRING=preg_replace("!<iframe(.?)</iframe>!is","",$STRING);
- &nbsp; 제거 : $STRING=str_replace(" "," ",$STRING);
- 복수 공백 하나로 : $STRING=preg_replace("/\s{2,}/"," ",$STRING)
- style= 제거 : $STRING=preg_replace("/ style=([^"']+) /"," ",$STRING); // style=border:0...
- style="" 제거 : $STRING=preg_replace("/ style=("|')?([^"']+)("|')?/","",$STRING); // style="border:0..."
- width= 제거 : $STRING=preg_replace("/ width=("|')?\d+("|')?/","",$STRING);
- height= 제거 : $STRING=preg_replace("/ height=("|')?\d+("|')?/","",$STRING);

### 참고사이트

heropy 정규표현식 정리 https://heropy.blog/2018/10/28/regexp/  
정규표현식 테스트 가능 https://regexr.com/
