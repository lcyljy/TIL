# 3월 23일 25장 study-3

## 25.8 상속에 의한 클래스 확장

### 25.8.1 클래스 상속과 생성자 함수 상속

상속에 의한 클래스확장은 지금까지 살펴본 프로토타입 기반 상속과는 다른 개념이다. 프로토타입 기반 상속은 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만 상속에의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것이다.

클래스와 생성자함수는 인스턴스를 생성할 수 있는 함수라는 점에서 매우 유사하다. 하지만 클래스는 상속을 통해 기존 클래스를 확장할 수 있는 문법이 기본적으로 제공되지만 생성자 함수는 그렇지 않다.

예를 들어, 동물을 추상화한 Animal 클래스와 새와 사자를 추상화한 Bird, Lion 클래스를 각각 정의한다고 생각해보자. 새와 사자는 동물에 속하므로 동물의 속성을 갖는다. 하지만 새와 사자는 자신만의 고유한 속성도 갖는다. 이 때 Animal 클래스는 동물의 속성을 표현하고, Bird, Lion 클래스는 상속을 통해 Animal 클래스의 속성을 그대로 사용하면서 자신만의 고유한 속성만 추가하여 확장할 수 있다.

Bird 클래스와 Lion 클래스는 상속을 통해 Animal 클래스의 속성을 그대로 사용하고 자신만의 고유한 속성을 추가하여 확장했다. 이처럼 상속에 의한 클래스 확장은 코드 재사용 관점에서 매우 유용하다.

상속을 통해 Animal 클래스를 확장한 Bird 클래스를 구현해보자

```js
  class Animal {
    constructor(age, weight){
      this.age = age;
      this.weight = weight;
    }

    eat() {return 'eat'; }

    move() { return 'move'; }
  }

  // 상속을 통해 Animal 클래스를 확장한 Bird 클래스
  class Bird extends Animal {
    fly() {return 'fly';}

    const bird = new Bird(1,5);

    console.log(bird); //Bird {age: 1. weight: 5}
    console.log(bird instance of Bird); // true
    console.log(bird instance of Animal) // true

    console.log(bird.eat());  // eat
    console.log(bird.move());  // move
    console.log(bird.fly()); // fly
  }
```

클래스는 상속을 통해 다른 클래스를 확장할 수 있는 문법인 extends 키워드가 기본적으로 제공된다. extends 키워드를 사용한 클래스 확장은 간편하고 직관적이다. 하지만 생성자 함수는 클래스와 같이 상속을 통해 다른 생성자 함수를 확장할 수 있는 문법이 제공되지 않는다.

자바스크립트는 클래스 기반 언어가 아니므로 생성자 함수를 사용하여 클래스를 흉내내려는 시도를 권장하지는 않지만 의사 클래스 상속 패턴을 사용하여 상속에 의한 클래스 확장을 흉내내기도 했다. 클래스의 등장으로 `의사 클래스 상속`[^1] 패턴은 더는 필요하지 않다.

[^1]: 의사 클래스 상속 패턴 (Pseudo-classical Inheritance) : 의사클래스 패턴은 자식 생성자 함수의 prototype 프로퍼티를 부모 생성자 함수의 인스턴스로 교체하여 상속을 구현하는 방법이다. 부모와 자식 모두 생성자 함수를 정의하여야 한다. (클래스기반 언어의 상속을 흉내내어 상속 구현, new연산자를 통해 인스턴스를 생성하는 문제, 생성자 링크의 파괴, 객체리터럴로 생성한 객체는 상속에 적합하지 않음 등의 문제로 현재는 사용되지 않음.) https://poiemaweb.com/js-object-oriented-programming

### 25.8.2 extends 키워드

상속을 통해 클래스를 확장하려면 extends 키워드를 사용하여 상속받을 클래스를 정의한다.

상속을 통해 확장된 클래스를 서브클래(sub)스라 부르고,  
 서브클래스에게 상속된 클래스를 수퍼(super)클래스라 부른다.  
 서브클래스를 파생(derived)클래스 또는 자식(child)클래스,  
 수퍼클래스를 베이스(base)클래스 또는 부모(parent)클래스 라고 부른다.

extends 키워드의 역할은 수퍼클래스와 서브 클래스 간의 상속 관계를 설정하는 것이다. 클래스도 프로토타입을 통해 상속 관계를 구현한다.

수퍼클래스와 서브클래스는 인스턴스의 프로토타입 체인 뿐 아니라 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메서드, 정적메서드 모두 상속이 가능하다.

### 25.8.3 동적 상속

extends 키워드는 클래스뿐만 아니라 생성자 함수를 상속받아 클래스를 확장할 수도 있다. 단 extends 키워드 앞에는 반드시 클래스가 와야한다.  
 extends 키워드 다음에는 클래스 뿐만이 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다. 이를 통해 동적으로 상속받을 대상을 결정할 수 있다.

### 25.8.4 서브클래스의 constructor

클래스에서 constructor를 생략하면 클래스에 비어있는 constructor가 암묵적으로 정의된다.
서브클래스에서 constructor를 생략하면 클래스에 다음과 같은 constructor가 정의된다. args는 new 연산자와 함께 클래스를 호출할 때 전달한 인수의 리스트다.

```js
  constructor(...args) { super(...args);}
```

super()는 수퍼클래스의 constructor(super-constructor)를 호출하여 인스턴스를 생성한다.

> 매개변수에 ...을 붙이면 Rest 파라미터가 된다. Rest 파리미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.

- 수퍼클래스와 서브클래스 모두 cosntructor를 생략하면 빈 객체가 생성됨. -> 프로퍼티를 소유하는 인스턴스를 생성하려면 constructor 내부에서 인스턴스에 프로퍼티를 추가해야함.

### 25.8.5 super 키워드

super 키워든느 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드다. super는 다음과 같이 동작한다.

    super를 호출하면 수퍼 클래스의 constructor(super-constructor)를 호출한다.
    super를 참조하면 수퍼 클래스의 메서드를 호출할 수 있다.

super 호출  
 super를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출한다.  
 수퍼클래스의 constructor 내부에서 추가한 프로퍼티를 그대로 갖는 인스턴스를 생성한다면 서브클래스의 constructor를 생략할 수 있다. 이 때 new 연산자와 함께 서브클래스를 호출하면서 전달한 인수는 모두 서브 클래스에 암묵적으로 정의된 super 호출을 통해 수퍼클래스의 constructor에 전달된다.

super 후출시 주의할 점

1. 서브클래스에서 constructor를 생략하지 않는 경우 서브클래스의 constructor에서는 반드시 super를 호출해야한다.
2. 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.
3. super는 반드시 서브클래스의 constructor에서만 호출한다. 서브클래스가 아닌 클래스의 constructor나 함수에서 super를 호출하면 에러가 발생한다.

super 참조  
 메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출할 ㅜㅅ 있다.

1. 서브 클래스의 프로토타입 메서드 내에서 super.(임의의 메서드)는 수퍼클래스의 프로토타입 메서드 (임의의 메서드)를 가리킨다.  
   super참조를 통해 수퍼클래스의 메서드를 참조하려면 super가 수퍼클래스의 메서드가 바인딩된 객체, 즉 수퍼클래스의 prototype 프로퍼티에 바인딩 된 프로토타입을 참조할 수 있어야 한다.  
   super는 자신을 참조하고 있는 메서드가 바인딩되어있는 객체의 프로토타입을 가리킨다.

- super 참조는 클래스의 전유물은 아니다. 객체리터럴에서도 super 참조를 사용할 수 있다. 단, ES6의 메서드 축약 표현으로 정의된 함수만 가능하다.
- ES6의 메서드 축약표현으로 정의도니 함수만이 [[HomeObject]]를 가지고, 이는 자신을 바인딩하고 잇는 객체를 가리킨다.

2. 서브 클래스의 정적 메섣느 내에서 super.(임의의 메서드)는 수퍼클래스의 정적 메서드 (임의의 메서드)를 가리킨다.

### 25.8.6 상속 클래스의 인스턴스 생성과정

1.  서브클래스의 super 호출  
    자바스크립트 엔진은 클래스를 평가할 때 수퍼클래스와 서브클래스를 구분하기 위해 "base" 또는 derived"를 값으로 갖는 내부슬롯 [[ConstructorKind]]를 갖는다. 다른 클래스를 상속받지 않는 클래스(그리고 생성자 함수)는 내부슬롯 [[ConstructorKind]의 값이 "base"로 설정되지만 다른 클래스를 상속받는 서브클래스는 내부슬롯 [[ConstructorKind]의 값이 "derived"로 설정된다. 이를 통해 수퍼클래스와 서브클래스는 new 연산자와 함께 호출되었을 때의 동작이 구분된다.  
    다른 클래스를 상속받지 않는 클래스(그리고 생성자함수)는 new 연산자와 함께 호출되었을 때 암묵적으로 빈 객체, 즉 인스턴스를 상ㅐㅇ성하고 이를 this에 바인딩한다.  
    하지만 서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다. 이것이 바로 서브클래스의 constructor에서 반드시 super를 호출해야 하는 이유다.  
    서브클래스가 new 연산자와 함께 호출되면 서브 클래스 constructor 내부의 super 키워드가 함수처럼 호출된다.super가 호출되면 수퍼 클래스의 constructor(super-constructor)가 호출된다. 좀 더 정확히 말하자면 수퍼클래스가 평가되어 생성된 함수 객체의 코드가 실행되기 시작한다.  
    만약 서브클래스 constructor 내부에 super 호출이 없으면 에러가 발생한다. 실제로 인스턴스를 생성하는 주체는 수퍼클래스이므로 수퍼클래스의 constructor를 호출하는 super가 호출되지 않으면 인스턴스를 생성할 수 없기 때문이다.

2.  슈퍼클래스의 인스턴스 생성과 this 바인딩  
    수퍼클래스의 constructor 내부의 코드가 실행되기 이전에 암묵적으로 빈 객체를 생성한다. 이 빈객체가 바로 클래스가 생성한 인스턴스다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩된다. 따라서 수퍼클래스의 constructor 내부의 this를 생성한 인스턴스를 가리킨다.  
    이때 인스턴스는 수퍼클래스가 생성한것이다. 하지만 new 연산자와 함께 호출된 클래스가 서브클래스라는 것이 중요하다. 즉 new 연산자와 함께 호출된 함수를 가리키는 new.target은 서브클래스를 가리킨다. 따라서 인스턴스는 new.target이 가리키는 서브클래스가 생성한 것으로 처리된다.  
    따라서 생성된 인스턴스의 프로토타입은 수퍼클래스의 prototype 프로퍼티가 가리키는 객체가 아니라 new.target, 즉 서브클래스의 prototype 프로퍼티가 가리키는 객체(ColorRectangle.prototype)다.

3.  슈퍼클래스의 인스턴스 초기화  
    수퍼클래스의 constructor가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 즉, this에 바인딩 되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전닳받은 초기값으로 인스턴스의 프로퍼티를 초기화한다.

4.  서브클래스의 constructor로의 복귀와 this 바인딩  
    super의 호출이 종료되거 제어 흐름이 서브 클래스 constructor로 돌아온다. 이 때 super가 반환한 인스턴스가 this에 바인딩된다. 서브클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩하여 그대로 사용한다.  
    이처럼 super가 호출되지 않으면 인스턴스가 생성되지 않으며, this 바인딩도 할 수 없다. 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없는 이유가 바로 이 때문이다. 따라서 서브클래스 constructor 내부의 인스턴스 초기화는 반드시 super 호출 이후에 처리되어야 한다.

5.  서브클래스의 인스턴스 초기화  
    super 호출 이후, 서브클래스의 constructor에 기술되어 있는 인스턴스 초기화가 실행된다. 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화한다.

6.  인스턴스 반환  
    클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.

### 25.8.7 표준 빌트인 생성자 함수 확장

extends 키워드 다음에는 클래스 뿐만이 아니라 [[Constructor]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다. 표준 빌트인 객체도 [[Constructor]] 내부 메서드를 갖는 생성자함수이므로 extends키워드를 사용하여 확장할 수 있다.\

## 23일 요약

프로토타입 기반 상속은 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만 상속에의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것  
클래스와 생성자함수는 인스턴스를 생성할 수 있는 함수라는 점에서 매우 유사  
클래스는 상속을 통해 기존 클래스를 확장할 수 있는 문법이 기본적으로 제공되지만 생성자 함수는 그렇지 않다.

프로토타입 기반 상속 - 체인을 통해 다른 객체의 자산을 상속
상속에 의한 클래스 확장 - extends 키워드를 통해 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의

- 의사 클래스 상속 패턴 (Pseudo-classical Inheritance) : 의사클래스 패턴은 자식 생성자 함수의 prototype 프로퍼티를 부모 생성자 함수의 인스턴스로 교체하여 상속을 구현하는 방법이다.

상속을 통해 확장된 클래스를 서브(sub)클래스라 부르고,
서브클래스에게 상속된 클래스를 수퍼(super)클래스라 부른다.
서브클래스를 파생(derived)클래스 또는 자식(child)클래스,
수퍼클래스를 베이스(base)클래스 또는 부모(parent)클래스 라고 부른다.

프로토타입 메서드, 정적메서드 모두 상속이 가능

extends 키워드 다음에는 클래스 뿐만이 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.

한줄 요약  
클래스 상속 : extends를 활용하여 상속 가능, 서브클래스에선 super를 사용하여 수퍼클래스의 생성자 호출가능.

의문. 그래서 프로토타입 체인과 클래스의 상속은 비슷한거 같은데 그 두개의 차이는 무엇일까?
프로토타입 상속은 체인에 걸친 속성 검색으로 성능에 나쁜 영향을 줄 수 있으며 때때로 치명적일 수 있다. 또한 존재하지도 않는 속성에 접근하려는 시도는 항상 모든 프로토타입 체인인 전체를 탐색해서 확인하게 만든다.
ex. 객체의 속성에 걸쳐 루프를 수행하는 경우 프로토타입 체인 전체의 모든 열거자 속성에 대하여 적용.

class 상속 - 인스턴스 하위 클래스 관계 생성
